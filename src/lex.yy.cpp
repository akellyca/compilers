// lex.yy.cpp generated by reflex 1.3.2 from proj0.lxx

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_lex                 yylex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_namespace           yy
#define REFLEX_OPTION_nodefault           true
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "lex.yy.cpp"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace yy {

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  static const int quote = 1;
  static const int Quote = 2;
  virtual int yylex();
  int yylex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return yylex();
  }
};

} // namespace yy

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 2 "proj0.lxx"

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
using namespace std;


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace yy {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace yy
namespace yy {
extern void reflex_code_quote(reflex::Matcher&);
} // namespace yy
namespace yy {
extern void reflex_code_Quote(reflex::Matcher&);
} // namespace yy

int yy::Lexer::yylex()
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  static const reflex::Pattern PATTERN_quote(reflex_code_quote);
  static const reflex::Pattern PATTERN_Quote(reflex_code_Quote);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              matcher().input();
            }
            break;
          case 1: // rule at line 17: [\x20]["]
#line 17 "proj0.lxx"
{cout<<"&ldquo"; start(Quote); }
            break;
          case 2: // rule at line 18: [\x20][']
#line 18 "proj0.lxx"
{cout<<"&ldquo"; start(quote); }

            break;
          case 3: // rule at line 24: .
#line 24 "proj0.lxx"
{echo();}



            break;
        }
        break;
      case quote:
        matcher().pattern(PATTERN_quote);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              matcher().input();
            }
            break;
          case 1: // rule at line 21: [^']
#line 21 "proj0.lxx"
{ echo(); }
            break;
          case 2: // rule at line 23: [']
#line 23 "proj0.lxx"
{cout<<"&rdquo"; start(INITIAL); }
            break;
        }
        break;
      case Quote:
        matcher().pattern(PATTERN_Quote);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              matcher().input();
            }
            break;
          case 1: // rule at line 20: [^"]
#line 20 "proj0.lxx"
{ echo(); }
            break;
          case 2: // rule at line 22: ["]
#line 22 "proj0.lxx"
{cout<<"&rdquo"; start(INITIAL); }
            break;
        }
        break;
      default:
        start(0);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 29 "proj0.lxx"
int main(int argc, char **argv) {
     yy::Lexer().yylex();
     cout << "\n";
     exit(0);
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#ifdef OS_WIN
#pragma warning(push)
#pragma warning(disable:4102)
#endif

namespace yy {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = c0;
  m.FSM_INIT(c1);

S0:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S4;
  if ('\v' <= c1) goto S8;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S8;
  return m.FSM_HALT(c1);

S4:
  m.FSM_TAKE(3);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\'') goto S12;
  if (c1 == '"') goto S10;
  return m.FSM_HALT(c1);

S8:
  m.FSM_TAKE(3);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S10:
  m.FSM_TAKE(1);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S12:
  m.FSM_TAKE(2);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);
}

} // namespace yy

#ifdef OS_WIN
#pragma warning(pop)
#endif
#include <reflex/matcher.h>

#ifdef OS_WIN
#pragma warning(push)
#pragma warning(disable:4102)
#endif

namespace yy {

void reflex_code_quote(reflex::Matcher& m)
{
  int c0 = 0, c1 = c0;
  m.FSM_INIT(c1);

S0:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\'') goto S4;
  if ('\0' <= c1) goto S2;
  return m.FSM_HALT(c1);

S2:
  m.FSM_TAKE(1);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S4:
  m.FSM_TAKE(2);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);
}

} // namespace yy

#ifdef OS_WIN
#pragma warning(pop)
#endif
#include <reflex/matcher.h>

#ifdef OS_WIN
#pragma warning(push)
#pragma warning(disable:4102)
#endif

namespace yy {

void reflex_code_Quote(reflex::Matcher& m)
{
  int c0 = 0, c1 = c0;
  m.FSM_INIT(c1);

S0:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '"') goto S4;
  if ('\0' <= c1) goto S2;
  return m.FSM_HALT(c1);

S2:
  m.FSM_TAKE(1);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S4:
  m.FSM_TAKE(2);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);
}

} // namespace yy

#ifdef OS_WIN
#pragma warning(pop)
#endif
